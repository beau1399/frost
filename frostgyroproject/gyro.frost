calls printu,orb,notb,utof,addf,divf,printf,ftou,add,dispose
altstack is 80
var scaler,ym,ye

event 1 is
 .add[1 @scaler] > scaler
 if .eq[2 @scaler],
  0 >scaler
/  .printch['*']
  .printf[@ym @ye]
  .printch[13]  .printch[10]
,,
;


insert clock
.clearbit[gie @intcon] > intcon
.clearbit[sspen @ssp1con1] > ssp1con1

8 > ssp1con1   		    /I2C aster mode
0 > ssp1con2		    /Default settings
19 > ssp1add  		    /32000000/(4*(1+SSPADD)); 19 -> 400k; Slow for now
18 > trisb		    /SCL and SDA as inputs
.clearbit[ansb4 @anselb] > anselb    /SCL and SDA non-analog
.clearbit[ansb1 @anselb] > anselb
.setbit[scie .setbit[pcie @ssp1con3]] > ssp1con3	/Start and Stop bit flagging on
.setbit[sspen @ssp1con1] > ssp1con1   /Start I2C

frost9600baud

.printch['O'].printch['K']

/Necessary to use MAX-232
/.clearbit[sckp @baudcon] > baudcon



.iicstart[]
.clearinterrupt[]
.checkack[]
210 > ssp1buf
.clearinterrupt[]
.checkack[]
107 > ssp1buf
.clearinterrupt[]
.checkack[]
0 > ssp1buf		/I think this is necess. to turn on the internal clock
.clearinterrupt[]
.checkack[]
.iicend[]
.clearinterrupt[]
.delay[]




.iicstart[]
.clearinterrupt[]
.checkack[]
210 > ssp1buf
.clearinterrupt[]
.checkack[]
26 > ssp1buf      /5 hertz sampling for more stability
.clearinterrupt[]
.checkack[]
6 > ssp1buf
.clearinterrupt[]
.checkack[]
.iicend[]
.clearinterrupt[]
.delay[]

0>scaler
insert slowtimer
insert starttimer


.loop[]

////////////////////////////////////////////////////

d .loop is

 .iicstart[]
 .clearinterrupt[]


 210 > sspbuf
 .clearinterrupt[]
 .checkack[]
 61 > sspbuf
 .clearinterrupt[]
 .checkack[]
 .setbit[rsen @ssp1con2] > ssp1con2
 .clearinterrupt[]
 211 > sspbuf
 .clearinterrupt[]
 .checkack[]
 .setbit[rcen @ssp1con2] > ssp1con2
 .clearfill[]
 .clearinterrupt[]
 .clearbit[ssp1if @pir1] > pir1
/ .printu[@ssp1buf]
 .copy[@ssp1buf]
 .printu[] .printch[' ']
 .clearbit[bf @ssp1stat] > ssp1stat


 .ack[]
 .clearinterrupt[]
 .setbit[rcen @ssp1con2] > ssp1con2
 .clearfill[]
 .clearinterrupt[]
 .clearbit[ssp1if @pir1] > pir1
/ .printu[@ssp1buf]

/.addf[ .itof[] .divf[ .itof[@ssp1buf] 256.0]] > ye > ym
 .dispose[@ssp1buf]
 .itof[]  > ye > ym

 .clearbit[bf @ssp1stat] > ssp1stat



 .nack[]
 .clearinterrupt[]
 .iicend[]
 .clearinterrupt[]
/ .printch[13] .printch[10]
 .loop[]
;

d .clearinterruptin is
 if .getbit[ssp1if @pir1],,.clearinterruptin[], 
;

d .clearinterrupt is
 .clearinterruptin[]
 .clearbit[3 @pir1] > pir1
;

d .clearfill is
 if .getbit[bf @ssp1stat],,.clearfill[], 
;

d .ack is
 .clearbit[ackdt @ssp1con2] > ssp1con2
 .setbit[acken @ssp1con2] > ssp1con2
;

d .nack is
 .setbit[ackdt @ssp1con2] > ssp1con2
 .setbit[acken @ssp1con2] > ssp1con2
;

d .checkack 0 0 is
 if .notb[.getbit[6 @ssp1con2]],,.printch['E'].printch['R'].printch['R']  .checkack[],
;

d .delay is
 ffor(.printch[' '])(20) /Delay 
;

d .iicstart is
 .setbit[sen @ssp1con2] > ssp1con2
;

d .iicend is
 .setbit[pen @ssp1con2] > ssp1con2
;

d .itof 1 2 is
 .add[128]
 .utof[.parm[0]]
 .addf[-128.0]
;

d .copy 1 2 is
 .parm[0] .parm[0]
;