macro stickyx is 10.0 end macro
macro ptermx is 30.0 end macro
macro itermx is 1.0 end macro
macro dtermx is -0.5 end macro

calls printu,notb,addf,gtf,andb/,printf,gtf,andb
altstack is 80
var scaler,ym,ye,xm,xe,zeroxm,zeroxe,zeroym,zeroye,init,errorxm,errorxe,tempm,tempe,commandm,commande

0.0 > errorxe > errorxm
insert clock
.clearbit[gie @intcon] > intcon
.clearbit[sspen @ssp1con1] > ssp1con1

8 > ssp1con1   		    /I2C master mode
0 > ssp1con2		    /Default settings
19 > ssp1add  		    /32000000/(4*(1+SSPADD)); 19 -> 400k; Slow for now
18 > trisb		    /SCL and SDA as inputs
.clearbit[ansb4 @anselb] > anselb    /SCL and SDA non-analog
.clearbit[ansb1 @anselb] > anselb
.setbit[scie .setbit[pcie @ssp1con3]] > ssp1con3	/Start and Stop bit flagging on
.setbit[sspen @ssp1con1] > ssp1con1   /Start I2C

/Not sure why but PWM doesn't work w/o these two calls
.setbit[txen @txsta] > txsta
.setbit[spen @rcsta] > rcsta

.iicstart[]
.clearinterrupt[]
.checkack[]
210 > ssp1buf
.clearinterrupt[]
.checkack[]
107 > ssp1buf
.clearinterrupt[]
.checkack[]
0 > ssp1buf		/I think this is necess. to turn on the internal clock
.clearinterrupt[]
.checkack[]
.iicend[]
.clearinterrupt[]
.delay[]

.iicstart[]
.clearinterrupt[]
.checkack[]
210 > ssp1buf
.clearinterrupt[]
.checkack[]
26 > ssp1buf      
.clearinterrupt[]
.checkack[]
6 > ssp1buf		/Low-pass filter (6 is max)
.clearinterrupt[]
.checkack[]
.iicend[]
.clearinterrupt[]
.delay[]
.pwm1on[] .pwm2on[]

.await[255]
.samplex[]
.sampley[]
.mulf[-1.0 @xm @xe] > zeroxe > zeroxm
.mulf[-1.0 @ym @ye] > zeroye > zeroym
ffor(.avgzero[])(20)


.clearbit[3 @trisa] > trisa 
.clearbit[3 @ansela] > ansela
/.setbit[3 @porta] > porta /Turn on LED for debugging

.loop[]

////////////////////////////////////////////////////

d .await * is
 .awaitin[255]
 if .notb[ .parm[0] ],,.add[-1] .await[],
;

d .awaitin * is
 if .notb[ .parm[0] ],.dispose[],.add[-1] .awaitin[],
;

d .loop is
 .samplex[]
 .sampley[]
 .addf[@zeroxm @zeroxe @xm @xe] > tempe > tempm		/tempx holds error for this iteration
 .addf[ @errorxm @errorxe @tempm @tempe] > errorxe > errorxm

/ if .gtf[@errorxm @errorxe imaxx],imaxx > errorxe > errorxm,
/  if .gtf[iminx @errorxm @errorxe ],iminx > errorxe > errorxm,,,

 /tempx holds command w/o differential part
 .addf[ .mulf[@errorxm @errorxe itermx] .mulf[ptermx @tempm @tempe ]] > tempe > tempm

 .addf[ @tempm @tempe
        .mulf[ .addf[ .mulf[-1.0 @commandm @commande] @tempm @tempe] dtermx ]] > commande > commandm

 .pwmf[ .addf[stickyx            @commandm @commande  ]  1]
 .pwmf[ .addf[stickyx .mulf[-1.0 @commandm @commande ]]  0]
 .setbit[3 @porta] > porta /Turn on LED for debugging
 .loop[]
;

d .clearinterruptin is
 if .getbit[ssp1if @pir1],,.clearinterruptin[], 
;

d .clearinterrupt is
 .clearinterruptin[]
 .clearbit[3 @pir1] > pir1
;

d .clearfill is
 if .getbit[bf @ssp1stat],,.clearfill[], 
;

d .ack is
 .clearbit[ackdt @ssp1con2] > ssp1con2
 .setbit[acken @ssp1con2] > ssp1con2
;

d .nack is
 .setbit[ackdt @ssp1con2] > ssp1con2
 .setbit[acken @ssp1con2] > ssp1con2
;

d .checkack 0 0 is
 if .notb[.getbit[6 @ssp1con2]],,.printch['E'].printch['R'].printch['R']  .checkack[],
;

d .delay is
 ffor(.printch[' '])(20) /Delay 
;

d .iicstart is
 .setbit[sen @ssp1con2] > ssp1con2
;

d .iicend is
 .setbit[pen @ssp1con2] > ssp1con2
;

d .samplex is
 .iicstart[]
 .clearinterrupt[]
 210 > sspbuf
 .clearinterrupt[]
 .checkack[]
 59 > sspbuf
 .clearinterrupt[]
 .checkack[]
 .setbit[rsen @ssp1con2] > ssp1con2
 .clearinterrupt[]
 211 > sspbuf
 .clearinterrupt[]
 .checkack[]
 .setbit[rcen @ssp1con2] > ssp1con2
 .clearfill[]
 .clearinterrupt[]
 .clearbit[ssp1if @pir1] > pir1
 @ssp1buf
 .clearbit[bf @ssp1stat] > ssp1stat

 .ack[]
 .clearinterrupt[]
 .setbit[rcen @ssp1con2] > ssp1con2
 .clearfill[]
 .clearinterrupt[]
 .clearbit[ssp1if @pir1] > pir1
 @ssp1buf
 .itoflong[]  > xe > xm
 .clearbit[bf @ssp1stat] > ssp1stat
;

d .sampley is

 .ack[]
 .clearinterrupt[]
 .setbit[rcen @ssp1con2] > ssp1con2
 .clearfill[]
 .clearinterrupt[]
 .clearbit[ssp1if @pir1] > pir1
 @ssp1buf
 .clearbit[bf @ssp1stat] > ssp1stat

 .ack[]
 .clearinterrupt[]
 .setbit[rcen @ssp1con2] > ssp1con2
 .clearfill[]
 .clearinterrupt[]
 .clearbit[ssp1if @pir1] > pir1
 @ssp1buf
 .itoflong[]  > ye > ym
 .clearbit[bf @ssp1stat] > ssp1stat

 .nack[]
 .clearinterrupt[]
 .iicend[]
 .clearinterrupt[]
;


d .avgzero is
  .samplex[]
  .sampley[]
  .mulf[0.5 .addf[.mulf[-1.0 @xm @xe] @zeroxm @zeroxe]]> zeroxe > zeroxm
  .mulf[0.5 .addf[.mulf[-1.0 @ym @ye] @zeroym @zeroye]]> zeroye > zeroym
;

insert itof
insert pwm