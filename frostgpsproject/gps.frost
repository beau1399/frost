/
/ GPS to UART program
/ Latitude only for now
/ On start, pauses until position fix obtained
/ Continues to print position once fix is obtained; if fix is lost,
/  last fix will keep printing
/ Fractional part of minutes are smoothing while continuously fixed
/

/// Directives ////////////////////////////////////////////////////////////

calls andb,geu,utof,addf,printf,printu,mulf,divf,iszerof,notb,iszerof,writeeeprom,readeeprom,debugptru

altstack is 80

var isgll,latdeg,latdegb,latmin,latminb,latsubmin,
    latsubminb,scaler,temp,tempb,filtervalid,fix,
    londeg,londegb,lonmin,lonminb,lonsubmin,lonsubminb

macro filter-factor is 0.5 end macro
macro one-minus-filter is 0.5 end macro

/// event() ///////////////////////////////////////////////////////////////

event 1 is
 .add[1 @scaler] > scaler
 if .andb[ @fix .eq[20 @scaler]],
  0 > scaler
  .printf[.readeeprom[0] .readeeprom[1]]
  .printch[' ']
  .printf[.readeeprom[2] .readeeprom[3]]
  .printch[' ']
  .printf[.readeeprom[4] .readeeprom[5]]
  .printch[13].printch[10]
  .printf[.readeeprom[6] .readeeprom[7]]
  .printch[' ']
  .printf[.readeeprom[8] .readeeprom[9]]
  .printch[' ']
  .printf[.readeeprom[10] .readeeprom[11]]
  .printch[13].printch[10]
  ,,
  .clearbit[1 @porta] > porta /Turn OFF light
  16 > iocbp /Interrupt on B4 change back on
;

event b is
 0 > iocbp /Interrupt on B4 change off for hysteresis
 .setbit[1 @porta] > porta /Turn ON light
 .writeeeprom[0 @latdeg]
 .writeeeprom[1 @latdegb]
 .writeeeprom[2 @latmin]
 .writeeeprom[3 @latminb]
 .writeeeprom[4 @latsubmin]
 .writeeeprom[5 @latsubminb]
 .writeeeprom[6 @londeg]
 .writeeeprom[7 @londegb]
 .writeeeprom[8 @lonmin]
 .writeeeprom[9 @lonminb]
 .writeeeprom[10 @lonsubmin]
 .writeeeprom[11 @lonsubminb]
; 

/// main() ////////////////////////////////////////////////////////////////

0 > filtervalid
0 > fix
insert clock
frost9600baud
/For MAX-232. We are using a 5V-to-RS232 bridge so we don't need tricks to make serial work.
.clearbit[sckp @baudcon] > baudcon
0 > isgll
0 > scaler
/ Start the 6hz timer


/ Global weak pull-up enabled... button will ground out B4
/ 7 is "not WPUEN"... not sure of friendly name
.clearbit[7 @option-reg] > option-reg 

/ Interrupts on, Interrupt-on-Change on
.setbit[gie .setbit[iocie @intcon]] > intcon

16 > iocbp /Interrupt on B4 change
16 > trisb /B4 is input
0 > anselb /B all digital
16 > wpub  /Pull B4 high

0 > trisa  /A is output
0 > ansela /A is digital



insert slowtimer
insert starttimer


.mainloop[]

/// functions //////////////////////////////////////////////////////////////

d .mainloop is
 .dofunc[]
 .mainloop[]
;

d .dofunc 0 0 is
 .receive[0 .getch[] 1]
;

macro readchar is
 .parm[0]>temp .dispose[] .receive[.getch[] .add[1 @temp]]
end macro

d .receive * is
/ 8 > portb
 if .eq[.parm[1] ','],  

////////////// COMMA HANDLER ////
     if .geu[@isgll 2],   /Are we working through the middle of a GLL string?

        /Yes; the 1 below is to force a real call vs. tail recursion.
        / We need to actually return here once required units have been read so that
        / we don't reach function bottom and return to dofunc early.
        .add[-1 @isgll]>isgll  readchar 1 , 

        /No; but are we at the end of a GLL string?
        if .eq[@isgll 1],
               /Yes... process!
               0>isgll .purge[],
               /Not in GLL string... look for new GLL string (or do nothing & continue if not found)
               if .andb[.eq[.parm[2] 'L']  .eq[.parm[3] 'L']],4>isgll,,,,,
////////////////////////////////
 
 /Didn't find comma this character
 if .geu[.parm[0] 28], 0 > filtervalid, readchar,,  /Just accumulate, unless GLL hasn't been timely
;


d .swapp 2 2 is
 .parm[0] .parm[1]
;

// GLL input processor /////////
d .purge * is
 if .eq[.parm[0] 27],
/.debugptru[] /188

  .addf[
   .addf[0.0
     .mulf[10.0 .utof[.add[.mul[-1 '0'].parm[27]]] ] ]
     .utof[.add[.mul[-1 '0'].parm[26]]]
   ] / > latdegb > latdeg
/.debugptru[] /190

  .addf[
  .addf[
   .addf[0.0
      .mulf[100.0 .utof[.add[.mul[-1 '0'].parm[14]]] ] ]
     .mulf[10.0 .utof[.add[.mul[-1 '0'].parm[13]]] ] ]
     .utof[.add[.mul[-1 '0'].parm[12]]]
   ] / > londegb > londeg
/.debugptru[] /192

  .addf[
   .addf[0.0
     .mulf[10.0 .utof[.add[.mul[-1 '0'].parm[25]]] ] ]
     .utof[.add[.mul[-1 '0'].parm[24]]]
  ] / > tempb > temp

  /Examine mantissa of minutes (middle of the three terms in
  / order of significance) and bust smooting if there was a
  / change.
  /if .eq[@temp @latmin],, 0 > filtervalid,
   0 > filtervalid
  
/  @tempb  > latminb
/  @temp  > latmin
/.debugptru[] /194

  .addf[
   .addf[0.0
     .mulf[10.0 .utof[.add[.mul[-1 '0'].parm[11]]] ] ]
     .utof[.add[.mul[-1 '0'].parm[10]]]
  ] / > tempb > temp

/  @tempb  > lonminb
/  @temp  > lonmin

/.debugptru[] /196

  .divf[.addf[.addf[.addf[ .addf[ .addf[0.0
     .mulf[10000.0 .utof[.add[.mul[-1 '0'].parm[22]]]]  ]
     .mulf[1000.0 .utof[.add[.mul[-1 '0'].parm[21]]]]   ]
     .mulf[100.0 .utof[.add[.mul[-1 '0'].parm[20]]]]    ]
     .mulf[10.0 .utof[.add[.mul[-1 '0'].parm[19]]]]     ]
     .utof[.add[.mul[-1 '0'].parm[18]]]]
     100000.0]
  > tempb > temp

/.debugptru[] /196


if @filtervalid,
    .addf[  /Active fix available... smooth
     .mulf[one-minus-filter @temp @tempb]
     .mulf[filter-factor @latsubmin @latsubminb]]  , />latsubminb >latsubmin,
    /No continuous fix; don't smooth
    @tempb /> latsubminb
    @temp /> latsubmin
    ,

/.debugptru[]

 .divf[.addf[.addf[.addf[ .addf[ .addf[0.0
     .mulf[10000.0 .utof[.add[.mul[-1 '0'].parm[8]]]]]
     .mulf[1000.0 .utof[.add[.mul[-1 '0'].parm[7]]]]]
     .mulf[100.0 .utof[.add[.mul[-1 '0'].parm[6]]]]]
     .mulf[10.0 .utof[.add[.mul[-1 '0'].parm[5]]]]]
     .utof[.add[.mul[-1 '0'].parm[4]]]] 100000.0]
  > tempb > temp
  if @filtervalid,
    .addf[  /Active fix available... smooth
     .mulf[one-minus-filter @temp @tempb]
     .mulf[filter-factor @lonsubmin @lonsubminb]] ,/ >lonsubminb >lonsubmin,
    /No continuous fix; don't smooth, but if we are here we now have a fix
    @tempb /> lonsubminb
    @temp /> lonsubmin
    1 > filtervalid 1 > fix,

/.debugptru[]

 .writeeeprom[.swapp[10]]
 .writeeeprom[.swapp[11]]
 .writeeeprom[.swapp[4]]
 .writeeeprom[.swapp[5]]
 .writeeeprom[.swapp[9]]
 .writeeeprom[.swapp[8]]
 .writeeeprom[.swapp[3]]
 .writeeeprom[.swapp[2]]
 .writeeeprom[.swapp[7]]
 .writeeeprom[.swapp[6]]
 .writeeeprom[.swapp[1]]
 .writeeeprom[.swapp[0]]

 , /If arg count is not correct (27), do nothing
 ,
;

